/* Meta-lexer to generate lexer rules from a specification file. 
 *
 * Copyright (C) 2021 Duncan Lowther
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

%{

#define MAX_LEN 63

char elid[MAX_LEN+1], tokid[MAX_LEN+1], keyterm[MAX_LEN+1], *func;
int multi = 1;

static void out_regex(char*);

#define YY_USER_INIT printf(" /* BEGIN AUTOGENERATED RULES */\n");

%}

%option noyywrap yylineno batch
%option noreject noyymore noinput nounput nodefault
%option never-interactive warn main

%x SETELID SETTOKID SETMID EXPECTLF EXPECTCOL RHS0 RHS VARKT

%%

\n			/* Ignore */
<*>[ \t\r]+		/* Ignore */
<INITIAL,EXPECTLF>;.*\n { BEGIN(INITIAL); }

@			{ BEGIN(SETELID); }
@~			{ BEGIN(SETMID); }

<SETELID>[a-zA-Z0-9_]+	{ strncpy(elid, yytext, MAX_LEN); func = "mkNode(E_"; BEGIN(SETTOKID); }
<SETMID>[a-zA-Z0-9_]+	{ strncpy(elid, yytext, MAX_LEN); func = "mkMod(T_"; BEGIN(SETTOKID); }
<SETTOKID>[a-zA-Z0-9_]+	{ strncpy(tokid, yytext, MAX_LEN); BEGIN(EXPECTLF); }
<SETTOKID>\n		{ strncpy(tokid, elid, MAX_LEN); BEGIN(INITIAL); }
<EXPECTLF>\n[ \t\r\n]*	{ BEGIN(INITIAL); }

[^ \t\r\n%@:;]+		{ snprintf(keyterm, MAX_LEN, "\"%s\"", yytext); BEGIN(EXPECTCOL); }
\%			{ BEGIN(VARKT); }
<VARKT>[^ \t\r\n:;]+	{ strncpy(keyterm, yytext, MAX_LEN); BEGIN(EXPECTCOL); }
<EXPECTCOL>:		{ multi = 0; BEGIN(RHS0); }
<RHS0>[^ \t\r\n]+	{ out_regex(yytext); BEGIN(RHS); } 

<RHS>[^ \t\r\n;]+	{ if(multi) printf("|"); else printf("\t|\n");
			  out_regex(yytext);
			}
<RHS>(;.*)?\n		{ if(multi) printf(")/{E}"); 
                          printf("\t{ %s%s, %s); return %s; }\n", func, elid, keyterm, tokid);
                          BEGIN(INITIAL);
      			} 
<RHS><<EOF>>		{ if(multi) printf(")/{E}");
			  printf("\t{ %s%s, %s); return %s; }\n /* END AUTOGENERATED RULES */\n",
					func, elid, keyterm, tokid); yyterminate();
			}
<INITIAL,EXPECTLF><<EOF>> { printf(" /* END AUTOGENERATED RULES */\n"); yyterminate(); }

<*>.						{ fprintf(stderr, "Error: unexpected character '%c'\n", *yytext); }
<SETELID,SETMID,EXPECTCOL,RHS0,VARKT>\n		{ fprintf(stderr, "Error: unexpected newline in state %d\n", YYSTATE); }
<SETELID,SETMID,SETTOKID,EXPECTCOL,RHS0,VARKT><<EOF>>	{ fprintf(stderr, "Error: unexpected end-of-file\n"); yyterminate(); }

%%

static void out_regex(char * spec) {
    char *s, *t;
    s = spec;
    t = strchr(s, '-');
    if(t) {
        if(!multi) {
            printf("(");
            multi = 1;
        }
	while(t) {
	    *t++ = '\0';
	    printf("%s{S}", s);
            s = t;
            t = strchr(s, '-');
	}
    }
    printf("%s", s);
}

